-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Experimental package for a language implemented by Haskell
--   
--   This package is only for experiment to implement CUTE Lang. Do not use
--   this any other purpose. This package would introduce breaking changes
--   without any notifications.
@package minicute-common-syntax
@version 0.1.0.0


-- | Common basic types used to define many other types
module Minicute.Data.Common.Identifier

-- | miniCUTE identifier type.
newtype Identifier
Identifier :: String -> Identifier
instance (Minicute.Data.Common.Identifier.Identifier Data.Type.Equality.~ t) => Control.Lens.Wrapped.Rewrapped Minicute.Data.Common.Identifier.Identifier t
instance Control.Lens.Wrapped.Wrapped Minicute.Data.Common.Identifier.Identifier
instance Data.Text.Prettyprint.Doc.Minicute.PrettyMC Minicute.Data.Common.Identifier.Identifier
instance Data.Text.Prettyprint.Doc.Internal.Pretty Minicute.Data.Common.Identifier.Identifier
instance GHC.Base.Semigroup Minicute.Data.Common.Identifier.Identifier
instance Data.String.IsString Minicute.Data.Common.Identifier.Identifier
instance GHC.Classes.Ord Minicute.Data.Common.Identifier.Identifier
instance GHC.Classes.Eq Minicute.Data.Common.Identifier.Identifier
instance Language.Haskell.TH.Syntax.Lift Minicute.Data.Common.Identifier.Identifier
instance Data.Data.Data Minicute.Data.Common.Identifier.Identifier
instance GHC.Generics.Generic Minicute.Data.Common.Identifier.Identifier
instance GHC.Show.Show Minicute.Data.Common.Identifier.Identifier


-- | Types for precedences of primitive operators in miniCUTE
module Minicute.Data.Common.Precedence

-- | Precedence of a unary/binary operator
data Precedence
PInfixN :: Int -> Precedence
[precedence] :: Precedence -> Int
PInfixL :: Int -> Precedence
[precedence] :: Precedence -> Int
PInfixR :: Int -> Precedence
[precedence] :: Precedence -> Int
PPrefix :: Int -> Precedence
[precedence] :: Precedence -> Int
PPostfix :: Int -> Precedence
[precedence] :: Precedence -> Int

-- | The maximum precedence value in miniCUTE.
miniApplicationPrecedence :: Int

-- | The supremum precedence value in miniCUTE.
miniApplicationPrecedence1 :: Int

-- | Check whether the input operator is infix (i.e. binary).
isInfix :: Precedence -> Bool

-- | <tt>prettyBinaryExpressionPrec p op opPrec e1 e2</tt> make a document
--   that includes e1, op and e2 in the order, and pass appropriate
--   precedences <tt>p1</tt> and <tt>p2</tt> to <tt>prettyPrec p1 e1</tt>
--   and <tt>prettyPrec p2 e2</tt> to give proper parenthesis.
prettyBinaryExpressionPrec :: Int -> Precedence -> Doc ann -> (Int -> Doc ann) -> (Int -> Doc ann) -> Doc ann

-- | Precedences of <tt>a</tt>s
type PrecedenceTable a = [PrecedenceTableEntry a]

-- | A precedence of <tt>a</tt>
type PrecedenceTableEntry a = (a, Precedence)
instance GHC.Read.Read Minicute.Data.Common.Precedence.Precedence
instance GHC.Show.Show Minicute.Data.Common.Precedence.Precedence
instance GHC.Classes.Ord Minicute.Data.Common.Precedence.Precedence
instance GHC.Classes.Eq Minicute.Data.Common.Precedence.Precedence
instance Language.Haskell.TH.Syntax.Lift Minicute.Data.Common.Precedence.Precedence
instance Data.Data.Data Minicute.Data.Common.Precedence.Precedence
instance GHC.Generics.Generic Minicute.Data.Common.Precedence.Precedence


module Minicute.Data.Common.Primitive
data Primitive
PrimAdd :: Primitive
PrimSub :: Primitive
PrimMul :: Primitive
PrimDiv :: Primitive
PrimEq :: Primitive
PrimNe :: Primitive
PrimLt :: Primitive
PrimLe :: Primitive
PrimGt :: Primitive
PrimGe :: Primitive
toString :: Primitive -> String

-- | All predefined precedences.
--   
--   All precedences should be smaller than
--   <a>miniApplicationPrecedence</a>. Where do I need to check this
--   condition?
primitivePrecedenceTable :: PrecedenceTable Primitive

-- | All precedences of binary primitives.
binaryPrimitivePrecedenceTable :: PrecedenceTable Primitive
instance GHC.Read.Read Minicute.Data.Common.Primitive.Primitive
instance GHC.Show.Show Minicute.Data.Common.Primitive.Primitive
instance GHC.Classes.Ord Minicute.Data.Common.Primitive.Primitive
instance GHC.Classes.Eq Minicute.Data.Common.Primitive.Primitive
instance Language.Haskell.TH.Syntax.Lift Minicute.Data.Common.Primitive.Primitive
instance Data.Data.Data Minicute.Data.Common.Primitive.Primitive
instance GHC.Generics.Generic Minicute.Data.Common.Primitive.Primitive
instance Data.Text.Prettyprint.Doc.Minicute.PrettyMC Minicute.Data.Common.Primitive.Primitive


module Minicute.Data.Common


-- | Common types for parsers
module Minicute.Parser.Common

-- | <tt>MonadParser</tt> is a constraint used to write generic parsers.
type MonadParser e s m = (MonadParsec e s m, ShowErrorComponent e, s ~ String, MonadFail m)

-- | <tt>Parser</tt> is a concrete type for parsers.
type Parser = Parsec Void String


-- | Common lexer functions used in miniCUTE compiler
module Minicute.Parser.Common.Lexer

-- | <tt>betweenRoundBrackets p</tt> parses <tt>"("</tt>, and then
--   <tt>p</tt>, and finally <tt>")"</tt>.
betweenRoundBrackets :: MonadParser e s m => m a -> m a

-- | <tt>gMachineIdentifier</tt> parses any character sequences not
--   containing <tt>';'</tt> or space characters as an identifier.
gMachineIdentifier :: MonadParser e s m => m (Tokens s)

-- | <tt>identifier</tt> parses any character sequences starting with
--   <tt>identifierFirstChar</tt> followed by <tt>identifierRestChar</tt>.
--   For example, this function parses <tt>"_abc"</tt>, <tt>"ab4"</tt>, and
--   <tt>"a_ef_3"</tt> successfully.
--   
--   For more examples, see the test module for this function.
identifier :: MonadParser e s m => m (Tokens s)

-- | <tt>keyword</tt> parses any keywords.
--   
--   The keywords are <tt>let</tt>, <tt>letrec</tt>, <tt>in</tt>,
--   <tt>match</tt>, <tt>with</tt>, and <tt>$C</tt>.
keyword :: MonadParser e s m => Tokens s -> m (Tokens s)

-- | <tt>symbol str</tt> parses <tt>str</tt> and ignore the result.
symbol :: MonadParser e s m => Tokens s -> m ()

-- | <tt>integer</tt> parses a decimal integer with no prefix, binary
--   integer with <tt>"0b"</tt> or <tt>"0B"</tt> prefix, octal integer with
--   <tt>"0o"</tt> or <tt>"0O"</tt> prefix, decimal integer with
--   <tt>"0d"</tt> or <tt>"0D"</tt> prefix, hexadecimal integer with
--   <tt>"0x"</tt> or <tt>"0X"</tt> prefix.
integer :: (MonadParser e s m, Integral a) => m a

-- | <tt>spacesConsumer</tt> consumes all consecutive spaces and ignore the
--   result.
spacesConsumer :: MonadParser e s m => m ()


module Minicute.Parser.Common.Parser
primitive :: Parser Primitive
createPrimitiveOperatorTable :: MonadParser e s m => (Primitive -> expr) -> (expr -> expr -> expr) -> (expr -> expr -> expr -> expr) -> PrecedenceTable Primitive -> [[Operator m expr]]


-- | Common utilities for miniCUTE compiler using TemplateHaskell
module Minicute.Utils.Common.TH

-- | parse quoted string as an indented code text.
qqRawCode :: QuasiQuoter
normalizeCode :: String -> String
