-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Experimental package for a language implemented by Haskell
--   
--   This package is only for experiment to implement CUTE Lang. Do not use
--   this any other purpose. This package would introduce breaking changes
--   without any notifications. For EBNF syntax, see
--   <a>https://github.com/CUTE-Lang/miniCUTE/blob/master/minicute-syntax/README.md</a>
@package minicute-minicute-syntax
@version 0.1.0.0


-- | Types for a miniCUTE expression
module Minicute.Data.Minicute.Expression

-- | A type used to represent a let definition of <tt>expr a</tt>.
newtype LetDefinition t l a
LetDefinition :: (a, Expression t l a) -> LetDefinition t l a

-- | A <a>MainLetDefinition</a> for <tt>ExpressionMC</tt> with
--   <a>Identifier</a>.
type MainLetDefinition t l = LetDefinition t l Identifier

-- | <a>Lens</a> to extract the binder of <a>LetDefinition</a>
_letDefinitionBinder :: Lens' (LetDefinition t l a) a

-- | <a>Lens</a> to extract the body expression of <a>LetDefinition</a>
_letDefinitionBody :: Lens (LetDefinition t l a) (LetDefinition t' l' a) (Expression t l a) (Expression t' l' a)

-- | A type used to represent a match case of <tt>expr a</tt>.
newtype MatchCase t l a
MatchCase :: (Integer, [a], Expression t l a) -> MatchCase t l a

-- | A <a>MatchCase</a> for <tt>ExpressionMC</tt> with <a>Identifier</a>.
type MainMatchCase t l = MatchCase t l Identifier

-- | <a>Lens</a> to extract the tag of <a>MatchCase</a>
_matchCaseTag :: Lens' (MatchCase t l a) Integer

-- | <a>Lens</a> to extract the arguments of <a>MatchCase</a>
_matchCaseArguments :: Lens' (MatchCase t l a) [a]

-- | <a>Lens</a> to extract the body expression of <a>MatchCase</a>
_matchCaseBody :: Lens (MatchCase t l a) (MatchCase t' l' a) (Expression t l a) (Expression t' l' a)

-- | <tt>IsRecursive</tt> represents recursiveness of let/letrec
--   expressions.
data IsRecursive

-- | Utility pattern for the recursive case of <a>IsRecursive</a>
pattern Recursive :: IsRecursive

-- | Utility pattern for the non-recursive case of <a>IsRecursive</a>
pattern NonRecursive :: IsRecursive
data ExpressionType
Simple :: ExpressionType
AnnotatedWith :: Type -> ExpressionType
data ExpressionLevel

-- | miniCUTE
MC :: ExpressionLevel

-- | Lambda lifted miniCUTE
LLMC :: ExpressionLevel

-- | A basic miniCUTE expression of <tt>a</tt>.
data Expression (t :: ExpressionType) (l :: ExpressionLevel) a

-- | <pre>
--   5
--   </pre>
[EInteger] :: Annotation t -> Integer -> Expression t l a

-- | <pre>
--   $C{t;a}
--   </pre>
[EConstructor] :: Annotation t -> Integer -> Integer -> Expression t l a

-- | <pre>
--   +
--   </pre>
[EPrimitive] :: Annotation t -> Primitive -> Expression t l a

-- | <pre>
--   v
--   </pre>
[EVariable] :: Annotation t -> Identifier -> Expression t l a

-- | <pre>
--   f 4
--   </pre>
[EApplication] :: Annotation t -> Expression t l a -> Expression t l a -> Expression t l a

-- | <pre>
--   let x = 4 in x
--   </pre>
[ELet] :: Annotation t -> IsRecursive -> [LetDefinition t l a] -> Expression t l a -> Expression t l a

-- | <pre>
--   match $C{1;0} with &lt;1&gt; -&gt; 4
--   </pre>
[EMatch] :: Annotation t -> Expression t l a -> [MatchCase t l a] -> Expression t l a

-- | <pre>
--   \x.x
--   </pre>
[ELambda] :: l ~  'MC => Annotation t -> [a] -> Expression t l a -> Expression t l a

-- | A <a>Expression</a> with <a>Identifier</a>.
type MainExpression t l = Expression t l Identifier

-- | A utility pattern for <a>Expression</a> of double application.
pattern EApplication2 :: forall (t :: ExpressionType) (l :: ExpressionLevel) a. () => () => Annotation t -> Annotation t -> Expression t l a -> Expression t l a -> Expression t l a -> Expression t l a

-- | A utility pattern for <a>Expression</a> of triple application.
pattern EApplication3 :: forall (t :: ExpressionType) (l :: ExpressionLevel) a. () => () => Annotation t -> Annotation t -> Annotation t -> Expression t l a -> Expression t l a -> Expression t l a -> Expression t l a -> Expression t l a

-- | <a>Lens</a> to extract the annotation of
--   <tt>AnnotatedExpressionMC</tt>.
_annotation :: Lens' (Expression t l a) (Annotation t)
instance (Minicute.Data.Minicute.Expression.IsRecursive Data.Type.Equality.~ t) => Control.Lens.Wrapped.Rewrapped Minicute.Data.Minicute.Expression.IsRecursive t
instance Control.Lens.Wrapped.Wrapped Minicute.Data.Minicute.Expression.IsRecursive
instance (Minicute.Data.Minicute.Expression.MatchCase t1 l1 a1 Data.Type.Equality.~ t2) => Control.Lens.Wrapped.Rewrapped (Minicute.Data.Minicute.Expression.MatchCase t3 l2 a2) t2
instance Control.Lens.Wrapped.Wrapped (Minicute.Data.Minicute.Expression.MatchCase t l a)
instance (Minicute.Data.Minicute.Expression.LetDefinition t1 l1 a1 Data.Type.Equality.~ t2) => Control.Lens.Wrapped.Rewrapped (Minicute.Data.Minicute.Expression.LetDefinition t3 l2 a2) t2
instance Control.Lens.Wrapped.Wrapped (Minicute.Data.Minicute.Expression.LetDefinition t l a)
instance GHC.Generics.Generic (Minicute.Data.Minicute.Expression.LetDefinition t l a)
instance GHC.Generics.Generic (Minicute.Data.Minicute.Expression.MatchCase t l a)
instance GHC.Generics.Generic Minicute.Data.Minicute.Expression.ExpressionType
instance GHC.Generics.Generic Minicute.Data.Minicute.Expression.ExpressionLevel
instance GHC.Classes.Ord Minicute.Data.Minicute.Expression.IsRecursive
instance GHC.Classes.Eq Minicute.Data.Minicute.Expression.IsRecursive
instance Language.Haskell.TH.Syntax.Lift Minicute.Data.Minicute.Expression.IsRecursive
instance Data.Data.Data Minicute.Data.Minicute.Expression.IsRecursive
instance GHC.Generics.Generic Minicute.Data.Minicute.Expression.IsRecursive
instance (Data.Data.Data a, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable l, Data.Data.Data (Minicute.Data.Minicute.Expression.Expression t l a)) => Data.Data.Data (Minicute.Data.Minicute.Expression.LetDefinition t l a)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift (Minicute.Data.Minicute.Expression.Expression t l a)) => Language.Haskell.TH.Syntax.Lift (Minicute.Data.Minicute.Expression.LetDefinition t l a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (Minicute.Data.Minicute.Expression.Expression t l a)) => GHC.Classes.Eq (Minicute.Data.Minicute.Expression.LetDefinition t l a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord (Minicute.Data.Minicute.Expression.Expression t l a)) => GHC.Classes.Ord (Minicute.Data.Minicute.Expression.LetDefinition t l a)
instance (GHC.Show.Show a, GHC.Show.Show (Minicute.Data.Minicute.Expression.Expression t l a)) => GHC.Show.Show (Minicute.Data.Minicute.Expression.LetDefinition t l a)
instance (Data.Data.Data a, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable l, Data.Data.Data (Minicute.Data.Minicute.Expression.Expression t l a)) => Data.Data.Data (Minicute.Data.Minicute.Expression.MatchCase t l a)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift (Minicute.Data.Minicute.Expression.Expression t l a)) => Language.Haskell.TH.Syntax.Lift (Minicute.Data.Minicute.Expression.MatchCase t l a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (Minicute.Data.Minicute.Expression.Expression t l a)) => GHC.Classes.Eq (Minicute.Data.Minicute.Expression.MatchCase t l a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord (Minicute.Data.Minicute.Expression.Expression t l a)) => GHC.Classes.Ord (Minicute.Data.Minicute.Expression.MatchCase t l a)
instance (GHC.Show.Show a, GHC.Show.Show (Minicute.Data.Minicute.Expression.Expression t l a)) => GHC.Show.Show (Minicute.Data.Minicute.Expression.MatchCase t l a)
instance (Data.Data.Data a, Data.Typeable.Internal.Typeable t, Data.Data.Data (Minicute.Data.Minicute.Expression.Annotation t)) => Data.Data.Data (Minicute.Data.Minicute.Expression.Expression t 'Minicute.Data.Minicute.Expression.MC a)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift (Minicute.Data.Minicute.Expression.Annotation t)) => Language.Haskell.TH.Syntax.Lift (Minicute.Data.Minicute.Expression.Expression t l a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (Minicute.Data.Minicute.Expression.Annotation t)) => GHC.Classes.Eq (Minicute.Data.Minicute.Expression.Expression t l a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord (Minicute.Data.Minicute.Expression.Annotation t)) => GHC.Classes.Ord (Minicute.Data.Minicute.Expression.Expression t l a)
instance (GHC.Show.Show a, GHC.Show.Show (Minicute.Data.Minicute.Expression.Annotation t)) => GHC.Show.Show (Minicute.Data.Minicute.Expression.Expression t l a)
instance (Data.Text.Prettyprint.Doc.Minicute.PrettyMC a, Data.Text.Prettyprint.Doc.Minicute.PrettyMC (Minicute.Data.Minicute.Expression.Expression t l a)) => Data.Text.Prettyprint.Doc.Minicute.PrettyMC (Minicute.Data.Minicute.Expression.LetDefinition t l a)
instance (Data.Text.Prettyprint.Doc.Minicute.PrettyMC a, Data.Text.Prettyprint.Doc.Minicute.PrettyMC (Minicute.Data.Minicute.Expression.Expression t l a)) => Data.Text.Prettyprint.Doc.Minicute.PrettyMC (Minicute.Data.Minicute.Expression.MatchCase t l a)
instance Data.Text.Prettyprint.Doc.Minicute.PrettyMC a => Data.Text.Prettyprint.Doc.Minicute.PrettyMC (Minicute.Data.Minicute.Expression.Expression 'Minicute.Data.Minicute.Expression.Simple l a)
instance (Data.Text.Prettyprint.Doc.Minicute.PrettyMC ann, Data.Text.Prettyprint.Doc.Minicute.PrettyMC a) => Data.Text.Prettyprint.Doc.Minicute.PrettyMC (Minicute.Data.Minicute.Expression.Expression ('Minicute.Data.Minicute.Expression.AnnotatedWith ann) l a)
instance GHC.Show.Show Minicute.Data.Minicute.Expression.IsRecursive


-- | Types for miniCUTE programs
module Minicute.Data.Minicute.Program

-- | A type for a supercombinator (top-level function definition)
--   
--   <ul>
--   <li><i><tt>Identifier</tt></i> the top-level identifier of the
--   definition.</li>
--   <li><i><tt>[a]</tt></i> the arguments of the definition.</li>
--   <li><i><tt>expr a</tt></i> the body expression of the definition.</li>
--   </ul>
newtype Supercombinator t l a
Supercombinator :: (Identifier, [a], Expression t l a) -> Supercombinator t l a

-- | A supercombinator of <a>MainExpression</a>
type MainSupercombinator t l = Supercombinator t l Identifier

-- | <a>Lens</a> to extract the binder of <a>Supercombinator</a>
_supercombinatorBinder :: Lens' (Supercombinator t l a) Identifier

-- | <a>Lens</a> to extract the list of arguments of <a>Supercombinator</a>
_supercombinatorArguments :: Lens' (Supercombinator t l a) [a]

-- | <a>Lens</a> to extract the body expression of <a>Supercombinator</a>
_supercombinatorBody :: Lens (Supercombinator t1 l1 a) (Supercombinator t2 l2 a) (Expression t1 l1 a) (Expression t2 l2 a)

-- | A type for a miniCUTE program
newtype Program t l a
Program :: [Supercombinator t l a] -> Program t l a

-- | A program of <a>MainExpression</a>
type MainProgram t l = Program t l Identifier
instance (Minicute.Data.Minicute.Program.Program t1 l1 a1 Data.Type.Equality.~ t2) => Control.Lens.Wrapped.Rewrapped (Minicute.Data.Minicute.Program.Program t3 l2 a2) t2
instance Control.Lens.Wrapped.Wrapped (Minicute.Data.Minicute.Program.Program t l a)
instance (Minicute.Data.Minicute.Program.Supercombinator t1 l1 a1 Data.Type.Equality.~ t2) => Control.Lens.Wrapped.Rewrapped (Minicute.Data.Minicute.Program.Supercombinator t3 l2 a2) t2
instance Control.Lens.Wrapped.Wrapped (Minicute.Data.Minicute.Program.Supercombinator t l a)
instance GHC.Generics.Generic (Minicute.Data.Minicute.Program.Program t l a)
instance GHC.Generics.Generic (Minicute.Data.Minicute.Program.Supercombinator t l a)
instance (Data.Data.Data a, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable l, Data.Data.Data (Minicute.Data.Minicute.Expression.Expression t l a)) => Data.Data.Data (Minicute.Data.Minicute.Program.Supercombinator t l a)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift (Minicute.Data.Minicute.Expression.Expression t l a)) => Language.Haskell.TH.Syntax.Lift (Minicute.Data.Minicute.Program.Supercombinator t l a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (Minicute.Data.Minicute.Expression.Expression t l a)) => GHC.Classes.Eq (Minicute.Data.Minicute.Program.Supercombinator t l a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord (Minicute.Data.Minicute.Expression.Expression t l a)) => GHC.Classes.Ord (Minicute.Data.Minicute.Program.Supercombinator t l a)
instance (GHC.Show.Show a, GHC.Show.Show (Minicute.Data.Minicute.Expression.Expression t l a)) => GHC.Show.Show (Minicute.Data.Minicute.Program.Supercombinator t l a)
instance (Data.Data.Data a, Data.Typeable.Internal.Typeable t, Data.Typeable.Internal.Typeable l, Data.Data.Data (Minicute.Data.Minicute.Expression.Expression t l a)) => Data.Data.Data (Minicute.Data.Minicute.Program.Program t l a)
instance (Language.Haskell.TH.Syntax.Lift a, Language.Haskell.TH.Syntax.Lift (Minicute.Data.Minicute.Expression.Expression t l a)) => Language.Haskell.TH.Syntax.Lift (Minicute.Data.Minicute.Program.Program t l a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq (Minicute.Data.Minicute.Expression.Expression t l a)) => GHC.Classes.Eq (Minicute.Data.Minicute.Program.Program t l a)
instance (GHC.Classes.Ord a, GHC.Classes.Ord (Minicute.Data.Minicute.Expression.Expression t l a)) => GHC.Classes.Ord (Minicute.Data.Minicute.Program.Program t l a)
instance (GHC.Show.Show a, GHC.Show.Show (Minicute.Data.Minicute.Expression.Expression t l a)) => GHC.Show.Show (Minicute.Data.Minicute.Program.Program t l a)
instance (Data.Text.Prettyprint.Doc.Minicute.PrettyMC a, Data.Text.Prettyprint.Doc.Minicute.PrettyMC (Minicute.Data.Minicute.Expression.Expression t l a)) => Data.Text.Prettyprint.Doc.Minicute.PrettyMC (Minicute.Data.Minicute.Program.Program t l a)
instance (Data.Text.Prettyprint.Doc.Minicute.PrettyMC a, Data.Text.Prettyprint.Doc.Minicute.PrettyMC (Minicute.Data.Minicute.Expression.Expression t l a)) => Data.Text.Prettyprint.Doc.Minicute.PrettyMC (Minicute.Data.Minicute.Program.Supercombinator t l a)


-- | Parser functions for miniCUTE
module Minicute.Parser.Minicute.Parser

-- | <tt>Parser</tt> is a concrete type for parsers.
type Parser = Parsec Void String
data ExpressionType
Simple :: ExpressionType
AnnotatedWith :: Type -> ExpressionType
data ExpressionLevel

-- | miniCUTE
MC :: ExpressionLevel

-- | Lambda lifted miniCUTE
LLMC :: ExpressionLevel

-- | A program of <a>MainExpression</a>
type MainProgram t l = Program t l Identifier

-- | A parser for <tt>MainProgramMC</tt>
mainProgramMC :: Parser (MainProgram  'Simple  'MC)

-- | A parser for <tt>MainProgramLLMC</tt>
mainProgramLLMC :: Parser (MainProgram  'Simple  'LLMC)


-- | Utilities for a miniCUTE expression
module Minicute.Utils.Minicute.Expression
destructStructureExpression :: Expression t l a -> Maybe (Integer, [Expression t l a])
lookupMCasesL :: Integer -> [MatchCase t l a] -> Maybe (MatchCase t l a)
lookupLDefsL :: Eq a => a -> [LetDefinition t l a] -> Maybe (LetDefinition t l a)


-- | Minicute syntax utilities for miniCUTE compiler using TemplateHaskell
module Minicute.Utils.Minicute.TH

-- | parse quoted string as a <tt>MainProgramMC</tt>.
qqMiniMainMC :: QuasiQuoter

-- | parse quoted string as a <tt>MainProgramLLMC</tt>.
qqMiniMainLLMC :: QuasiQuoter

-- | parse quoted string as an indented code text.
qqRawCode :: QuasiQuoter
