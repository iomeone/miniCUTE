-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Experimental package for a language implemented by Haskell
--   
--   This package is only for experiment to implement CUTE Lang. Do not use
--   this any other purpose. This package would introduce breaking changes
--   without any notifications.
@package minicute-g-machine-interpreter
@version 0.1.0.0


module Control.Lens.Operators.Minicute
(%%~=) :: MonadState s m => LensLike (AlongsideRight m r) s s a b -> (a -> m (r, b)) -> m r
infixr 4 %%~=


module Minicute.Data.GMachine.Address
data Address

-- | Constructor for <a>Address</a>
address :: Integer -> Address
minimumAddress :: Address
increaseAddress :: Address -> Address
instance GHC.Show.Show Minicute.Data.GMachine.Address.Address
instance GHC.Classes.Ord Minicute.Data.GMachine.Address.Address
instance GHC.Classes.Eq Minicute.Data.GMachine.Address.Address
instance Data.Data.Data Minicute.Data.GMachine.Address.Address
instance GHC.Generics.Generic Minicute.Data.GMachine.Address.Address
instance Data.Text.Prettyprint.Doc.Internal.Pretty Minicute.Data.GMachine.Address.Address


module Minicute.Data.GMachine.AddressStack
data AddressStack
empty :: AddressStack
pushAddr :: (MonadState s m, s ~ AddressStack) => Address -> m ()
pushAddrs :: (MonadState s m, s ~ AddressStack) => [Address] -> m ()
popAddr :: (MonadState s m, s ~ AddressStack, MonadFail m) => m Address
popAddrs :: (MonadState s m, s ~ AddressStack, MonadFail m) => Int -> m [Address]
popAllAddrs :: (MonadState s m, s ~ AddressStack) => m [Address]
peekAddr :: (MonadState s m, s ~ AddressStack, MonadFail m) => m Address
peekNthAddr :: (MonadState s m, s ~ AddressStack, MonadFail m) => Int -> m Address
peekAllAddrs :: (MonadState s m, s ~ AddressStack) => m [Address]
checkSize :: (MonadState s m, s ~ AddressStack, MonadFail m) => Int -> m Bool
instance (Minicute.Data.GMachine.AddressStack.AddressStack Data.Type.Equality.~ t) => Control.Lens.Wrapped.Rewrapped Minicute.Data.GMachine.AddressStack.AddressStack t
instance Control.Lens.Wrapped.Wrapped Minicute.Data.GMachine.AddressStack.AddressStack
instance GHC.Show.Show Minicute.Data.GMachine.AddressStack.AddressStack
instance GHC.Classes.Ord Minicute.Data.GMachine.AddressStack.AddressStack
instance GHC.Classes.Eq Minicute.Data.GMachine.AddressStack.AddressStack
instance Data.Data.Data Minicute.Data.GMachine.AddressStack.AddressStack
instance GHC.Generics.Generic Minicute.Data.GMachine.AddressStack.AddressStack


module Minicute.Data.GMachine.Code
data Code
empty :: Code
initialCode :: Code
fetchNextInstruction :: (MonadState s m, s ~ Code, MonadFail m) => m Instruction
putInstruction :: (MonadState s m, s ~ Code) => Instruction -> m ()
putInstructions :: (MonadState s m, s ~ Code) => [Instruction] -> m ()
assertLastCode :: (MonadState s m, s ~ Code, MonadFail m) => m ()
instance (Minicute.Data.GMachine.Code.Code Data.Type.Equality.~ t) => Control.Lens.Wrapped.Rewrapped Minicute.Data.GMachine.Code.Code t
instance Control.Lens.Wrapped.Wrapped Minicute.Data.GMachine.Code.Code
instance GHC.Show.Show Minicute.Data.GMachine.Code.Code
instance GHC.Classes.Ord Minicute.Data.GMachine.Code.Code
instance GHC.Classes.Eq Minicute.Data.GMachine.Code.Code
instance Data.Data.Data Minicute.Data.GMachine.Code.Code
instance GHC.Generics.Generic Minicute.Data.GMachine.Code.Code


module Minicute.Data.GMachine.Global

-- | miniCUTE identifier type.
newtype Identifier
Identifier :: String -> Identifier
data Global
empty :: Global
allocAddress :: (MonadState s m, s ~ Global) => Identifier -> Address -> m ()
updateAddress :: (MonadState s m, s ~ Global, MonadFail m) => Identifier -> Address -> m ()
findAddress :: (MonadState s m, s ~ Global, MonadFail m) => Identifier -> m Address
findAllAddresses :: (MonadState s m, s ~ Global, MonadFail m) => m [Address]
instance (Minicute.Data.GMachine.Global.Global Data.Type.Equality.~ t) => Control.Lens.Wrapped.Rewrapped Minicute.Data.GMachine.Global.Global t
instance Control.Lens.Wrapped.Wrapped Minicute.Data.GMachine.Global.Global
instance GHC.Show.Show Minicute.Data.GMachine.Global.Global
instance GHC.Classes.Ord Minicute.Data.GMachine.Global.Global
instance GHC.Classes.Eq Minicute.Data.GMachine.Global.Global
instance Data.Data.Data Minicute.Data.GMachine.Global.Global
instance GHC.Generics.Generic Minicute.Data.GMachine.Global.Global


module Minicute.Data.GMachine.Node
data Node
NEmpty :: Node
NInteger :: Integer -> Node
NStructure :: Integer -> Address -> Node
NStructureFields :: Integer -> [Address] -> Node
NApplication :: Address -> Address -> Node
NIndirect :: Address -> Node
NGlobal :: Integer -> GMachineExpression -> Node
isValueNode :: Node -> Bool
instance GHC.Show.Show Minicute.Data.GMachine.Node.Node
instance GHC.Classes.Ord Minicute.Data.GMachine.Node.Node
instance GHC.Classes.Eq Minicute.Data.GMachine.Node.Node
instance Data.Data.Data Minicute.Data.GMachine.Node.Node
instance GHC.Generics.Generic Minicute.Data.GMachine.Node.Node


module Minicute.Data.GMachine.NodeHeap
data NodeHeap
empty :: NodeHeap
allocNode :: (MonadState s m, s ~ NodeHeap) => Node -> m Address
updateNode :: (MonadState s m, s ~ NodeHeap, MonadFail m) => Address -> Node -> m ()
findNode :: (MonadState s m, s ~ NodeHeap, MonadFail m) => Address -> m Node
mark :: (MonadState s m, s ~ NodeHeap, MonadFail m) => [Address] -> m ()
sweep :: (MonadState s m, s ~ NodeHeap) => m ()
instance (Minicute.Data.GMachine.NodeHeap.NodeHeap Data.Type.Equality.~ t) => Control.Lens.Wrapped.Rewrapped Minicute.Data.GMachine.NodeHeap.NodeHeap t
instance Control.Lens.Wrapped.Wrapped Minicute.Data.GMachine.NodeHeap.NodeHeap
instance GHC.Show.Show Minicute.Data.GMachine.NodeHeap.NodeHeap
instance GHC.Classes.Ord Minicute.Data.GMachine.NodeHeap.NodeHeap
instance GHC.Classes.Eq Minicute.Data.GMachine.NodeHeap.NodeHeap
instance Data.Data.Data Minicute.Data.GMachine.NodeHeap.NodeHeap
instance GHC.Generics.Generic Minicute.Data.GMachine.NodeHeap.NodeHeap


module Minicute.Data.GMachine.ValueStack
data ValueStack
empty :: ValueStack
pushValue :: (MonadState s m, s ~ ValueStack) => Integer -> m ()
popValue :: (MonadState s m, s ~ ValueStack, MonadFail m) => m Integer
instance (Minicute.Data.GMachine.ValueStack.ValueStack Data.Type.Equality.~ t) => Control.Lens.Wrapped.Rewrapped Minicute.Data.GMachine.ValueStack.ValueStack t
instance Control.Lens.Wrapped.Wrapped Minicute.Data.GMachine.ValueStack.ValueStack
instance GHC.Show.Show Minicute.Data.GMachine.ValueStack.ValueStack
instance GHC.Classes.Ord Minicute.Data.GMachine.ValueStack.ValueStack
instance GHC.Classes.Eq Minicute.Data.GMachine.ValueStack.ValueStack
instance Data.Data.Data Minicute.Data.GMachine.ValueStack.ValueStack
instance GHC.Generics.Generic Minicute.Data.GMachine.ValueStack.ValueStack


module Minicute.Data.GMachine.Dump
data Dump
empty :: Dump
saveState :: (MonadState s m, s ~ Dump) => DumpItem -> m ()
loadState :: (MonadState s m, s ~ Dump, MonadFail m) => m DumpItem
extractAllAddresses :: (MonadState s m, s ~ Dump, MonadFail m) => m [Address]
type DumpItem = (Code, AddressStack, ValueStack)
emptyDumpItem :: DumpItem
instance (Minicute.Data.GMachine.Dump.Dump Data.Type.Equality.~ t) => Control.Lens.Wrapped.Rewrapped Minicute.Data.GMachine.Dump.Dump t
instance Control.Lens.Wrapped.Wrapped Minicute.Data.GMachine.Dump.Dump
instance GHC.Show.Show Minicute.Data.GMachine.Dump.Dump
instance GHC.Classes.Ord Minicute.Data.GMachine.Dump.Dump
instance GHC.Classes.Eq Minicute.Data.GMachine.Dump.Dump
instance Data.Data.Data Minicute.Data.GMachine.Dump.Dump
instance GHC.Generics.Generic Minicute.Data.GMachine.Dump.Dump


module Minicute.Data.GMachine.State
data GMachineState
buildInitialState :: GMachineProgram -> GMachineState
checkTerminalState :: GMachineState -> Bool
fetchNextInstruction :: (MonadState s m, s ~ GMachineState, MonadFail m) => m Instruction
putInstruction :: (MonadState s m, s ~ GMachineState) => Instruction -> m ()
putInstructions :: (MonadState s m, s ~ GMachineState) => [Instruction] -> m ()
assertLastCode :: (MonadState s m, s ~ GMachineState, MonadFail m) => m ()
garbageCollection :: (MonadState s m, s ~ GMachineState, MonadFail m) => m ()
allocNodeOnNodeHeap :: (MonadState s m, s ~ GMachineState) => Node -> m Address
updateNodeOnNodeHeap :: (MonadState s m, s ~ GMachineState, MonadFail m) => Address -> Node -> m ()
findNodeOnNodeHeap :: (MonadState s m, s ~ GMachineState, MonadFail m) => Address -> m Node
allocAddressOnGlobal :: (MonadState s m, s ~ GMachineState) => Identifier -> Address -> m ()
updateAddressOnGlobal :: (MonadState s m, s ~ GMachineState, MonadFail m) => Identifier -> Address -> m ()
findAddressOnGlobal :: (MonadState s m, s ~ GMachineState, MonadFail m) => Identifier -> m Address
pushAddrToAddressStack :: (MonadState s m, s ~ GMachineState) => Address -> m ()
pushAddrsToAddressStack :: (MonadState s m, s ~ GMachineState) => [Address] -> m ()
popAddrFromAddressStack :: (MonadState s m, s ~ GMachineState, MonadFail m) => m Address
popAddrsFromAddressStack :: (MonadState s m, s ~ GMachineState, MonadFail m) => Int -> m [Address]
popAllAddrsFromAddressStack :: (MonadState s m, s ~ GMachineState) => m [Address]
peekAddrOnAddressStack :: (MonadState s m, s ~ GMachineState, MonadFail m) => m Address
peekNthAddrOnAddressStack :: (MonadState s m, s ~ GMachineState, MonadFail m) => Int -> m Address
checkSizeOfAddressStack :: (MonadState s m, s ~ GMachineState, MonadFail m) => Int -> m Bool
pushValueToValueStack :: (MonadState s m, s ~ GMachineState) => Integer -> m ()
popValueFromValueStack :: (MonadState s m, s ~ GMachineState, MonadFail m) => m Integer
saveStateToDump :: (MonadState s m, s ~ GMachineState) => m ()
loadStateFromDump :: (MonadState s m, s ~ GMachineState, MonadFail m) => m ()
instance GHC.Classes.Eq Minicute.Data.GMachine.State.PrettyGMSVerbosity
instance Data.Text.Prettyprint.Doc.Internal.Pretty Minicute.Data.GMachine.State.GMachineState
instance Minicute.Data.GMachine.State.PrettyGMS Minicute.Data.GMachine.AddressStack.AddressStack
instance Minicute.Data.GMachine.State.PrettyGMS Minicute.Data.GMachine.Code.Code
instance Minicute.Data.GMachine.State.PrettyGMS Minicute.Data.GMachine.Dump.Dump
instance Minicute.Data.GMachine.State.PrettyGMS Minicute.Data.GMachine.Global.Global
instance Minicute.Data.GMachine.State.PrettyGMS Minicute.Data.GMachine.NodeHeap.NodeHeap
instance Minicute.Data.GMachine.State.PrettyGMS Minicute.Data.GMachine.ValueStack.ValueStack
instance Minicute.Data.GMachine.State.PrettyGMS Minicute.Data.GMachine.Node.Node
instance GHC.Show.Show Minicute.Data.GMachine.State.GMachineState
instance GHC.Classes.Ord Minicute.Data.GMachine.State.GMachineState
instance GHC.Classes.Eq Minicute.Data.GMachine.State.GMachineState
instance Data.Data.Data Minicute.Data.GMachine.State.GMachineState
instance GHC.Generics.Generic Minicute.Data.GMachine.State.GMachineState


module Minicute.Control.GMachine.Step
data GMachineStepMonadT m a
type GMachineStepMonad = GMachineStepMonadT IO
runGMachineStepT :: GMachineStepMonadT m a -> GMachineState -> m (a, GMachineState)
execGMachineStepT :: Monad m => GMachineStepMonadT m a -> GMachineState -> m GMachineState
instance Control.Monad.Trans.Class.MonadTrans Minicute.Control.GMachine.Step.GMachineStepMonadT
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Minicute.Control.GMachine.Step.GMachineStepMonadT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Minicute.Control.GMachine.Step.GMachineStepMonadT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Minicute.Control.GMachine.Step.GMachineStepMonadT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Minicute.Control.GMachine.Step.GMachineStepMonadT m)
instance GHC.Generics.Generic (Minicute.Control.GMachine.Step.GMachineStepMonadT m a)
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState Minicute.Data.GMachine.State.GMachineState (Minicute.Control.GMachine.Step.GMachineStepMonadT m)


module Minicute.Control.GMachine
data GMachineMonadT m a
type GMachineMonad = GMachineMonadT IO
execGMachineT :: MonadFail m => GMachineMonadT m a -> m (NonEmpty GMachineState)
initializeGMachineWith :: Monad m => GMachineProgram -> GMachineMonadT m ()
executeGMachineStep :: Monad m => GMachineStepMonadT m () -> GMachineMonadT m ()
checkGMachineFinished :: Monad m => GMachineMonadT m Bool
instance GHC.Base.Functor m => GHC.Base.Functor (Minicute.Control.GMachine.GMachineMonadT m)
instance GHC.Generics.Generic (Minicute.Control.GMachine.GMachineMonadT m a)
instance GHC.Base.Monad m => GHC.Base.Applicative (Minicute.Control.GMachine.GMachineMonadT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Minicute.Control.GMachine.GMachineMonadT m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Minicute.Control.GMachine.GMachineMonadT m)
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState (GHC.Base.NonEmpty Minicute.Data.GMachine.State.GMachineState) (Minicute.Control.GMachine.GMachineMonadT m)
instance Control.Monad.Trans.Class.MonadTrans Minicute.Control.GMachine.GMachineMonadT


module Minicute.Interpreter.GMachine.Instruction
interpretInstruction :: Instruction -> GMachineStepMonad ()


module Minicute.Interpreter.GMachine
interpretProgram :: GMachineProgram -> GMachineMonad ()
